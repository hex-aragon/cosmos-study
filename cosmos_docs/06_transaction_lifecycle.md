# Transaction Lifecycle

- 개요
  이 문서는 트랜잭션 생성부터 커밋된 상태 변경까지 트랜잭션의 라이프사이클에 대해 설명합니다. 트랜잭션 정의는 다른 문서에 설명되어 있습니다. 트랜잭션을 Tx라고 합니다.

# Creation

## Transaction Creation

주요 애플리케이션 인터페이스 중 하나는 명령줄 인터페이스입니다. 사용자가 명령줄에서 다음 형식의 명령을 입력하고 [command]에 트랜잭션 유형을, [args]에 인수를, [flags]에 가스 가격 등의 구성을 입력하면 트랜잭션 Tx를 생성할 수 있습니다:

```
[appname] tx [command] [args] [flags]
```

이 명령은 자동으로 트랜잭션을 생성하고 계정의 개인 키를 사용하여 서명하여 지정된 피어 노드로 브로드캐스트합니다. 트랜잭션 생성을 위한 몇 가지 필수 및 선택적 플래그가 있습니다. from 플래그는 트랜잭션이 어느 계정에서 시작되었는지를 지정합니다. 예를 들어 코인을 송금하는 트랜잭션의 경우 지정된 발신 주소에서 자금이 인출됩니다.

### Gas and Fees

또한 사용자가 수수료로 지불할 의사가 있는 금액을 표시하는 데 사용할 수 있는 몇 가지 플래그가 있습니다:

- --gas는 계산 리소스를 나타내는 Tx가 소비하는 가스의 양을 나타냅니다. 가스는 트랜잭션에 따라 달라지며 실행될 때까지 정확하게 계산되지 않지만

- --gas의 값으로 자동을 제공하여 추정할 수 있습니다. 가스 조정(옵션)은 과소 추정을 피하기 위해 가스 규모를 조정하는 데 사용할 수 있습니다. 예를 들어 사용자는 가스 조정을 1.5로 지정하여 예상 가스의 1.5배를 사용할 수 있습니다. 가스 가격은 사용자가 가스 단위당 지불하고자 하는 금액을 지정하며, 토큰 단위는 하나 또는 여러 개일 수 있습니다. 예를 들어

- --gas-prices=0.025uatom, 0.025upho는 사용자가 가스 단위당 0.025uatom과 0.025upho를 지불할 의사가 있음을 의미합니다.

- --fees는 사용자가 총 지불할 수수료 금액을 지정합니다.

- --timeout-height는 특정 높이 이상으로 tx가 커밋되는 것을 방지하기 위한 블록 타임아웃 높이를 지정합니다.

지불한 수수료의 최종 가치는 가스에 가스 가격을 곱한 값과 같습니다. 즉, 수수료 = 한도(가스 \* 가스 가격)입니다. 따라서 수수료는 가스 가격을 사용해 계산할 수도 있고 그 반대로 계산할 수도 있으므로 사용자는 둘 중 하나만 지정합니다. 나중에 검증자는 주어진 또는 계산된 가스 가격과 현지 최소 가스 가격을 비교하여 트랜잭션을 블록에 포함할지 여부를 결정합니다. 가스 가격이 충분히 높지 않으면 트랜잭션이 거부되므로 사용자는 더 많은 금액을 지불하도록 인센티브를 받게 됩니다.

### CLI Example

애플리케이션 앱 사용자는 CLI에 다음 명령을 입력하여 발신자 주소에서 수신자 주소로 1000uatom을 전송하는 트랜잭션을 생성할 수 있습니다. 이 명령은 지불하고자 하는 가스 금액을 지정합니다. 단위 가스당 0.025uatom의 가스 가격으로 1.5배 확장된 자동 견적이 표시됩니다.

```
appd tx send <recipientAddress> 1000uatom --from <senderAddress> --gas auto --gas-adjustment 1.5 --gas-prices 0.025uatom
```

### Other Transaction Creation Methods

명령줄은 애플리케이션과 상호작용하는 쉬운 방법이지만, gRPC나 REST 인터페이스 또는 애플리케이션 개발자가 정의한 다른 진입점을 사용해 Tx를 생성할 수도 있습니다. 사용자 관점에서 상호 작용은 사용 중인 웹 인터페이스나 지갑에 따라 달라집니다(예: Lunie.io를 사용해 Tx를 생성하고 Ledger Nano S로 서명하는 경우).

## Addition to Mempool

Tx를 수신하는 각 풀노드(CometBFT 실행)는 유효성을 확인하기 위해 ABCI 메시지인 CheckTx를 애플리케이션 레이어에 전송하고 abci.ResponseCheckTx를 받습니다. Tx가 검사를 통과하면 각 노드에 고유한 트랜잭션의 인메모리 풀인 노드의 Mempool에 보관되어 블록에 포함될 때까지 대기하며, 정직한 노드는 유효하지 않은 것으로 확인되면 Tx를 삭제합니다. 합의에 앞서 노드는 들어오는 트랜잭션을 지속적으로 확인하여 동료 노드에게 가십을 보냅니다.

### Types of Checks

풀 노드는 유효하지 않은 트랜잭션을 가능한 한 빨리 식별하고 거부하여 계산 낭비를 방지하는 것을 목표로 CheckTx 동안 Tx에서 상태 비저장 검사를 수행한 다음 상태 저장 검사를 수행합니다. 상태 비저장 검사는 노드가 상태에 액세스할 필요가 없으며 라이트 클라이언트나 오프라인 노드가 수행할 수 있으므로 계산 비용이 덜 듭니다. 상태 비저장 검사에는 주소가 비어 있지 않은지 확인, 음수가 아닌 숫자 적용 및 정의에 명시된 기타 로직이 포함됩니다.

상태 저장 검사는 커밋된 상태를 기반으로 트랜잭션과 메시지의 유효성을 검사합니다. 예를 들어 관련 값이 존재하고 거래할 수 있는지, 주소에 충분한 자금이 있는지, 발신자가 거래할 권한이 있는지 또는 올바른 소유권을 가지고 있는지 등을 확인합니다. 풀 노드는 일반적으로 애플리케이션의 내부 상태를 다양한 목적으로 여러 버전으로 관리합니다. 예를 들어, 노드는 트랜잭션을 검증하는 과정에서 상태 변경을 실행하지만 쿼리에 응답하기 위해서는 마지막으로 커밋된 상태의 복사본이 필요하며, 커밋되지 않은 변경이 있는 상태를 사용해 응답해서는 안 됩니다. 풀 노드는 Tx를 검증하기 위해 상태 비저장 및 상태 저장 확인을 모두 포함하는 CheckTx를 호출합니다. 추가 검증은 나중에 DeliverTx 단계에서 이루어집니다. CheckTx는 Tx 디코딩부터 시작하여 여러 단계를 거칩니다.

### Decoding

애플리케이션이 기본 합의 엔진(예: CometBFT )으로부터 Tx를 수신하면 인코딩된 []바이트 형식이므로 처리하기 위해 마샬링을 해제해야 합니다. 그런 다음 runTx 함수가 호출되어 runTxModeCheck 모드에서 실행됩니다. 즉, 함수는 모든 검사를 실행하지만 메시지를 실행하고 상태 변경 사항을 기록하기 전에 종료됩니다.

### ValidateBasic (deprecated)

메시지(sdk.Msg)는 트랜잭션(Tx)에서 추출됩니다. 모듈 개발자가 구현한 sdk.Msg 인터페이스의 ValidateBasic 메서드는 각 트랜잭션에 대해 실행됩니다. 명백하게 유효하지 않은 메시지를 삭제하기 위해 BaseApp 유형은 CheckTx 및 DeliverTx 트랜잭션에서 메시지 처리 초기에 ValidateBasic 메서드를 호출합니다. 유효성 검사에는 상태 없는 검사(상태에 액세스할 필요가 없는 검사)만 포함할 수 있습니다.

```
DANGER
위험 각 메시지 서비스에서 직접 메시지의 유효성을 검사하는 것을 선호하여 메시지에 대한 ValidateBasic 메서드가 더 이상 사용되지 않습니다. 자세한 내용은 RFC 001을 참조하세요.

- BaseApp은 이전 버전과의 호환성을 위해 해당 메서드를 구현하는 메시지에서 여전히 ValidateBasic을 호출합니다.

```

가이드 라인
ValidateBasic은 더 이상 사용하지 않아야 합니다. 메시지 서버 모듈에서 메시지를 처리할 때 메시지 유효성 검사는 메시지 서비스에서 수행해야 합니다.

## AnteHandler

사전 처리기는 선택 사항이지만 실제로는 서명 확인, 가스 계산, 수수료 공제 및 기타 블록체인 트랜잭션과 관련된 핵심 작업을 수행하는 데 자주 사용됩니다. 캐시된 컨텍스트의 사본이 사전 처리기에 제공되며, 트랜잭션 유형에 지정된 제한된 확인을 수행합니다. 복사본을 사용하면 AnteHandler가 마지막으로 커밋된 상태를 수정하지 않고 트랜잭션에 대한 상태 저장 검사를 수행하고 실행이 실패하면 원본으로 되돌릴 수 있습니다. 예를 들어 인증 모듈 AnteHandler는 시퀀스 번호를 확인 및 증가시키고, 서명과 계좌 번호를 확인하고, 트랜잭션의 첫 서명자로부터 수수료를 차감하며, 모든 상태 변경은 checkState를 사용하여 이루어집니다.

```
위험 앤트 핸들러는 트랜잭션에서만 실행됩니다. 트랜잭션에 여러 개의 메시지가 포함된 경우(예: 일부 x/authz, x/gov 트랜잭션), 앤티 핸들러는 외부 메시지만 인식합니다. 내부 메시지는 대부분 메시지 라우터로 직접 라우팅되며 앤티 핸들러의 체인을 건너뜁니다. 자체 앤트 핸들러를 설계할 때 이 점을 염두에 두세요.
```

### Gas

Tx를 실행하는 동안 사용된 가스의 양을 추적하는 GasMeter를 보관하는 컨텍스트가 초기화됩니다. 사용자가 제공한 Tx용 가스의 양을 GasWanted라고 합니다. 실행 중 소비된 가스의 양인 GasConsumed가 GasWanted를 초과하면 실행이 중지되고 캐시된 상태 복사본에 대한 변경 사항이 커밋되지 않습니다. 그렇지 않으면 CheckTx는 GasUsed를 GasConsumed와 동일하게 설정하고 결과에 이를 반환합니다. 가스 및 수수료 값을 계산한 후 검증자 노드는 사용자가 지정한 가스 가격이 로컬에서 정의한 최소 가스 가격보다 큰지 확인합니다.

### Discard or Addition to Mempool

CheckTx 중 어느 시점에서든 Tx가 실패하면 트랜잭션은 폐기되고 트랜잭션 수명 주기는 거기서 끝납니다. 그렇지 않고 CheckTx를 성공적으로 통과하면 기본 프로토콜은 이를 피어 노드에 전달하고 멤풀에 추가하여 다음 블록에 포함될 후보가 되도록 합니다. 멤풀은 모든 풀 노드가 본 트랜잭션을 추적하는 용도로 사용됩니다. 풀 노드는 리플레이 공격을 막기 위한 1차 방어선으로 마지막으로 본 mempool.cache_size 트랜잭션의 멤풀 캐시를 보관합니다. 이상적으로 mempool.cache_size는 전체 mempool의 모든 트랜잭션을 포함할 수 있을 만큼 충분히 큰 것이 좋습니다. 멤풀 캐시가 너무 작아서 모든 트랜잭션을 추적할 수 없는 경우, 재생된 트랜잭션을 식별하고 거부하는 것은 CheckTx가 담당합니다. 현재 기존의 예방 조치에는 수수료와 시퀀스(논스) 카운터가 포함되어 재생된 트랜잭션과 동일하지만 유효한 트랜잭션을 구별합니다. 공격자가 많은 Tx 사본으로 노드를 스팸하려고 하면 멤풀 캐시를 보관하는 풀 노드는 CheckTx를 실행하는 대신 동일한 사본을 모두 거부합니다. 사본의 시퀀스 번호가 증가하더라도 공격자는 수수료를 지불해야 하므로 유인을 잃게 됩니다.

# Inclusion in a Block

검증자 노드가 어떤 트랜잭션을 수락할지 합의하는 과정인 합의는 라운드로 진행됩니다. 각 라운드는 제안자가 가장 최근 트랜잭션 블록을 생성하는 것으로 시작하여 합의를 담당하는 투표권을 가진 특수 풀 노드인 검증자가 해당 블록을 수락하거나 무블록으로 진행할지 동의하는 것으로 끝납니다. 검증자 노드는 합의에 도달하기 위해 애플리케이션에 ABCI 요청을 사용하여 트랜잭션을 확인하는 CometBFT와 같은 합의 알고리즘을 실행합니다. 합의의 첫 번째 단계는 블록 제안입니다. 합의 알고리즘은 검증자 중 한 명의 제안자를 선택하여 블록을 생성하고 제안하며, 트랜잭션이 포함되려면 이 제안자의 멤풀에 있어야 합니다.

# State Changes

합의의 다음 단계는 트랜잭션을 실행하여 트랜잭션의 유효성을 완전히 검증하는 것입니다. 올바른 제안자로부터 블록 제안을 받은 모든 풀노드는 ABCI 함수 FinalizeBlock을 호출하여 트랜잭션을 실행합니다. 문서 전체에서 언급했듯이 BeginBlock, ExecuteTx 및 EndBlock은 FinalizeBlock 내에서 호출됩니다. 모든 풀노드가 개별적으로 로컬에서 작동하지만, 결과는 항상 일관되고 명확합니다. 이는 메시지로 인한 상태 변화를 예측할 수 있고, 트랜잭션이 제안된 블록에서 구체적으로 순서화되어 있기 때문입니다.

```
        --------------------------
        | Receive Block Proposal |
        --------------------------
                    |
                    v
        -------------------------
        |     FinalizeBlock      |
        -------------------------
                    |
                    v
            -------------------
            |   BeginBlock     |
            -------------------
                    |
                    v
            --------------------
            | ExecuteTx(tx0)   |
            | ExecuteTx(tx1)   |
            | ExecuteTx(tx2)   |
            | ExecuteTx(tx3)   |
            |       .          |
            |       .          |
            |       .          |
            -------------------
                    |
                    v
            --------------------
            |    EndBlock      |
            --------------------
                    |
                    v
        -------------------------
        |       Consensus        |
        -------------------------
                    |
                    v
        -------------------------
        |         Commit         |
        -------------------------

```

# Transaction Execution

합의 중에 커밋된 순서대로 블록의 각 트랜잭션에 대해 순차적으로 실행되며, 대부분의 상태 전환을 수행하는 것은 BaseApp에 정의된 FinalizeBlock ABCI 함수입니다. 내부적으로 트랜잭션 실행은 CheckTx와 거의 동일하지만, 체크 모드 대신 전달 모드에서 runTx 함수를 호출합니다. 풀 노드는 체크스테이트 대신 파이널라이즈블록을 사용합니다:

- 디코딩: FinalizeBlock은 ABCI 호출이므로, Tx는 인코딩된 []바이트 형식으로 수신됩니다. 노드는 먼저 앱에 정의된 TxConfig를 사용하여 트랜잭션을 언마샬링한 다음, 실행 모드 파이널라이즈에서 실행Tx를 호출하는데, 이는 CheckTx와 매우 유사하지만 상태 변경 사항을 실행하고 기록하기도 합니다.

- Checks 및 AnteHandler: 풀 노드는 validateBasicMsgs와 AnteHandler를 다시 호출합니다. 이 두 번째 검사는 멤풀에 추가하는 단계에서 동일한 트랜잭션을 보지 못했을 수 있고 악의적인 제안자가 유효하지 않은 트랜잭션을 포함했을 수 있기 때문에 발생합니다. 여기서 한 가지 차이점은 가스 가격은 각 노드에 국한된 값이므로 AnteHandler는 가스 가격을 노드의 최소 가스 가격과 비교하지 않으며, 노드 간에 값이 다르면 비결정적인 결과를 낳는다는 것입니다.

- MsgServiceRouter: CheckTx가 종료된 후에도 FinalizeBlock은 runMsgs를 계속 실행하여 트랜잭션 내의 각 메시지를 완전히 실행합니다. 트랜잭션에 여러 모듈의 메시지가 있을 수 있으므로 BaseApp은 적절한 핸들러를 찾을 모듈을 알아야 합니다. 이는 모듈의 Protobuf 메시지 서비스에서 처리할 수 있도록 BaseApp의 MsgServiceRouter를 사용하여 수행됩니다. 레거시 메시지 라우팅의 경우 모듈 관리자를 통해 라우트 함수를 호출하여 경로 이름을 검색하고 모듈 내에서 레거시 핸들러를 찾습니다.

메시지 서비스: Protobuf Msg 서비스는 Tx의 각 메시지 실행을 담당하며, 상태 전환이 finalizeBlockState.

PostHandlers에서 지속되도록 합니다: 포스트 핸들러는 메시지가 실행된 후에 실행됩니다. 실패하면 PostHandlers뿐만 아니라 runMsgs의 상태 변경도 모두 되돌려집니다.

가스: Tx가 전달되는 동안 GasMeter를 사용하여 사용 중인 가스 양을 추적하고, 실행이 완료되면 GasUsed가 설정되어 abci.ExecTxResult에 반환됩니다. 블록 가스 미터 또는 가스 미터가 부족하거나 다른 문제가 발생하여 실행이 중단되면 마지막에 지연된 함수가 적절하게 오류를 발생시키거나 패닉을 일으킵니다.

트랜잭션이 유효하지 않거나 가스 미터가 부족하여 상태 변경에 실패하면 트랜잭션 처리가 종료되고 모든 상태 변경이 되돌려집니다. 블록 제안에 유효하지 않은 트랜잭션이 있으면 검증자 노드는 해당 블록을 거부하고 대신 무효 블록에 투표합니다.

# Commit

마지막 단계는 노드가 블록과 상태 변경 사항을 커밋하는 것입니다. 검증자 노드는 트랜잭션의 유효성을 검사하기 위해 상태 전환을 실행하는 이전 단계를 수행한 다음 블록에 서명하여 이를 확인합니다. 검증자가 아닌 풀 노드는 합의에 참여하지 않으며, 즉 투표할 수 없지만 상태 변경을 커밋할지 여부를 파악하기 위해 투표를 기다립니다. 충분한 검증자 투표(투표력에 따라 가중치를 둔 2/3 이상의 사전 커밋)를 받으면 풀 노드는 블록체인에 추가될 새 블록을 커밋하고 애플리케이션 레이어에서 상태 전환을 마무리합니다. 새로운 상태 루트가 생성되어 상태 전환에 대한 머클 증명 역할을 합니다. 애플리케이션은 Baseapp에서 상속된 Commit ABCI 메서드를 사용하여 애플리케이션의 내부 상태에 deliverState를 기록함으로써 모든 상태 전환을 동기화합니다. 상태 변경이 커밋되는 즉시 가장 최근에 커밋된 상태부터 checkState가 새로 시작되고, 일관성을 유지하고 변경 사항을 반영하기 위해 deliverState가 0으로 재설정됩니다.

모든 블록에 동일한 수의 트랜잭션이 있는 것은 아니며, 합의에 따라 블록이 0이 되거나 전혀 없는 블록이 될 수도 있습니다. 퍼블릭 블록체인 네트워크에서는 검증자가 비잔틴 또는 악의적일 수 있으며, 이로 인해 블록체인에서 트랜잭션 검증이 이루어지지 않을 수도 있습니다. 가능한 악의적인 행동으로는 제안자가 Tx를 블록에서 제외하여 검열하기로 결정하거나 검증자가 블록에 반대 투표하는 것 등이 있습니다. 이 시점에서 노드는 Tx의 유효성을 확인하고 상태 변경을 실행하여 전달하고 변경 사항을 커밋하는 트랜잭션 수명 주기가 끝났습니다. 트랜잭션 트랜잭션은 []바이트 형식으로 블록에 저장되어 블록체인에 추가됩니다.



